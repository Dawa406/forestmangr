% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nls_table.R
\name{nls_table}
\alias{nls_table}
\title{Ajuste de funcoes nao lineares com saida customizada}
\usage{
nls_table(df, modelo, mod_start, .groups, output = "table",
  est.name = "est", replace = F, keep_model = F, global_start,
  algorithm = "LM")
}
\arguments{
\item{df}{Data frame a ser utilizado.}

\item{modelo}{Modelo que sera ajustado. Pode ser entrado de com ou sem aspas. lados x e y da equacao devem ser separados por "~".}

\item{mod_start}{Valores iniciais para os coeficientes do modelo. Pode ser um vetor contendo apenas um valor para cada coeficiente, ou um dataframe contendo valores de coeficiente por um determinado grupo.}

\item{.groups}{(Opcional) Nomes entre aspas das variaveis classificatorias que podem ser utilizadas para se realizar a regressao por grupo. Caso este argumento seja \code{NULL}, serao utilizados grupos ja definidos no dataframe. Caso nao sejam encontrados grupos no dataframe, a regressao sera aplicada para todo o dataframe. Padrao: \code{NULL}.}

\item{output}{Indica se a saida sera a tabela de coeficientes, a tabela unida aos dados originais ou o y estimado. Pode ter como entrada "table", "merge", "est" ou "nest". Padrao: \code{"table"}.}

\item{est.name}{Nome do y estimado, caso \code{est = TRUE}. Padrao: \code{"est"}.}

\item{replace}{Indica se ajustes por grupo que nao convergiram devem ser substituidos pelo modelo ajustado para todos os tados. Padrão \code{FALSE}.}

\item{keep_model}{Indica se a variavel contendo o(s) ajuste(s) deve ser mantida ou nao. Padrão: \code{FALSE}.}

\item{algorithm}{Algoritmo a ser utilizado. Pode ser \code{"LM"} (Levenberg-Marquardt, mais robusto) ou \code{"GN"} (Gauss-Newton, menos robusto, utiliza a funcao nls padrao). Padrão: \code{"LM"}.}
}
\value{
Dataframe. Sua composicao varia de acordo com o argumento ouput.
}
\description{
Funcao para se gerar uma tabela por grupo ou nao contendo apenas as informacoes mais importantes de uma regressao nao linear,
utilizando o algoritmo Levenberg-Marquardt ou Gauss-Newton.
Possui integracao com o pacote dplyr.
}
\details{
Com esta funcao nao ha a necessidade de se utilizar a funcao do() para se ajustar um modelo linear
dentro de um pipe do dplyr. Alem disso sua saida com os coeficientes em forma de coluna e
propria para a aplicacao do modelo, podendo-se chamar os coeficientes por nome ou posicao na coluna.
Alem disso, caso output = "merge", une-se o dataframe original aos coeficientes gerados automaticamente.
}
\examples{
library(forestmangr)
library(dplyr)
data("ex14_mfr")
dados <- ex14_mfr
head(dados)

# Ajustar o modelo nao linear de Chapman e Richards para todos os dados
nls_table(dados, HD ~ b0 * (1 - exp( -b1 * idade )  )^b2, 
         mod_start = c( b0=23, b1=0.03, b2 = 1.3  ) )

# Ajustar o modelo nao linear de Chapman e Richards por talhao
nls_table(dados,HD ~ b0 * (1 - exp( -b1 * idade )  )^b2,
         mod_start = c( b0=23, b1=0.03, b2 = 1.3  ),
         "talhao")
         
# ou, utilizando group_by

dados \%>\% 
group_by(talhao) \%>\% 
nls_table(HD ~ b0 * (1 - exp( -b1 * idade )  )^b2,
         mod_start = c( b0=23, b1=0.03, b2 = 1.3  ) )


# Percebe-se que nao houve convergencia em aguns talhoes; neste caso gera-se NAs.
# E possivel substituir estes NAs pelos coeficientes ajustados para todos os dados,
# com o argumento replace:
nls_table(dados,HD ~ b0 * (1 - exp( -b1 * idade )  )^b2, 
         mod_start = c( b0=23, b1=0.03, b2 = 1.3  ),
         "talhao",
         replace = T )

# Caso se tenha uma tabela com varios chutes iniciais, um para cada talhao, por exemplo,
# pode-se utiliza-la da seguinte forma:
tab_coef <- data.frame(talhao = c(1:20, 24,25,27,28,30,31,33,35,36,37), 
                      rbind(data.frame(b0 = rep(23, 20), b1 = rep(0.03, 20), b2 = rep(1.3, 20) ), 
                            data.frame(b0 = rep(23, 10), b1 = rep(0.03, 10), b2 = rep(.5, 10) )  )  )

# Basta inserir o dataframe no argumento mod_start
nls_table(dados, HD ~ b0 * (1 - exp( -b1 * idade )  )^b2, 
         mod_start = tab_coef ,
         "talhao",
         replace = F )
# lembrando que este deve ser um datafame, neste caso.

nls_table(dados, HD ~ b0 * (1 - exp( -b1 * idade )  )^b2, 
         mod_start = tab_coef ,
         "talhao",
         replace = T )

# E possivel tambem unir os coeficientes obitidos aos dados originais para conveniencia, 
# facilitando na hora de se estimar a variavel posteriormente:
nls_table(dados,HD ~ b0 * (1 - exp( -b1 * idade )  )^b2, 
         mod_start = tab_coef ,
         "talhao", 
         replace = T,
         output = "merge" ) \%>\% 
 mutate(
 HD_EST = b0 * (1 - exp( -b1 * idade )  )^b2,
 bias = bias_por(y = HD, yhat = HD_EST),
 rmse = rmse_por(y = HD, yhat = HD_EST) )

# ou, estimar a variavel diretamente utilizando o output "est"
nls_table(dados,HD ~ b0 * (1 - exp( -b1 * idade )  )^b2, 
         mod_start = tab_coef ,
         "talhao", 
         replace = T,
         output = "est", 
         est.name = "HD_EST" ) \%>\% 
 mutate(
 bias = bias_por(y = HD, yhat = HD_EST),
 rmse = rmse_por(y = HD, yhat = HD_EST) )

# No processo interno desta funcao, sao utilizadas
# "list_columns", que sao convertidos em colunas comuns 
# posteriormente. Caso seja de interesse do usuario trabalhar
# com estas colunas, basta utilizar o output "nest":
nls_table(dados,HD ~ b0 * (1 - exp( -b1 * idade )  )^b2, 
         mod_start = tab_coef ,
         "talhao",
         output = "nest" )
             
             
# Utilizar algoritmo Gauss-Newton, o mesmo da funcao nls             
dados \%>\% 
group_by(talhao) \%>\% 
nls_table(HD ~ b0 * (1 - exp( -b1 * idade )  )^b2,
         mod_start = c( b0=23, b1=0.03, b2 = 1.3  ),algorithm="GN" )

}
\author{
Sollano Rabelo Braga \email{sollanorb@gmail.com}
}
