% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lm_table.R
\name{lm_table}
\alias{lm_table}
\title{Ajuste de funcoes lineares com saida customizada}
\usage{
lm_table(df, modelo, .groups, output = "table", est.name = "est",
  keep_model = F)
}
\arguments{
\item{df}{Data frame a ser utilizado.}

\item{modelo}{Modelo que sera ajustado. Pode ser entrado de com ou sem aspas. lados x e y da equacao devem ser separados por "~".}

\item{.groups}{(opcional) Variaveis classificatorias que serao utilizadas para realizar a regressao por grupos. Caso este argumento seja \code{NULL}, serao utilizados grupos ja definidos no dataframe. Caso nao sejam encontrados grupos no dataframe, a regressao sera aplicada para todo o dataframe. Padrao: \code{NULL}.}

\item{output}{Indica se a saida sera a tabela de coeficientes, a tabela unida aos dados originais ou o y estimado. Pode ter como entrada "table", "merge", "est" ou "nest". Padrao: \code{"table"}.}

\item{est.name}{Nome do y estimado, caso \code{est = TRUE}. Padrao: \code{"est"}.}

\item{keep_model}{Indica se a variavel contendo o(s) ajuste(s) deve ser mantida ou nao. Padrao: \code{FALSE}.}
}
\value{
Dataframe. Sua composicao varia de acordo com o argumento ouput.
}
\description{
Funcao para se gerar uma tabela por grupo ou nao contendo apenas as informacoes mais importantes de uma regressao.
Possui integracao com o pacote dplyr.
}
\details{
Com esta funcao nao ha a necessidade de se utilizar a funcao do() para se ajustar um modelo linear
dentro de um pipe do dplyr. Alem disso sua saida com os coeficientes em forma de coluna e
propria para a aplicacao do modelo, podendo-se chamar os coeficientes por nome ou posicao na coluna.
Alem disso, caso output = "merge", une-se o dataframe original aos coeficientes gerados automaticamente.
}
\examples{
library(forestmangr)
library(dplyr)

data("ex7_mfr")
head(ex7_mfr)

# Para preparar gerar dados de exemplo para a regressao, 
# utiliza-se a funcao smaliancc:
dados_smalian <- smaliancc(ex7_mfr,"di_cc", "hi","ARVORE") \%>\% 
   group_by(FAZENDA, PROJETO, TALHAO, MATGEN, ARVORE ) \%>\% 
   summarise(VCC=sum(VCC,na.rm=T), DAP=mean(DAP), HT=mean(HT) ) \%>\% 
   ungroup
   
dados_smalian

# Agora sera ajustado o modelo de Schumacher e Hall:

# Rodar regressao, e gerar tabela com coeficientes, R2 e erro:
lm_table(dados_smalian, log(VCC) ~  log(DAP) + log(HT))

# ou
dados_smalian \%>\% 
  lm_table(log(VCC) ~  log(DAP) + log(HT) )
  

# Rodar regressao por talhao, e gerar tabela com coeficientes, R2 e erro:
lm_table(dados_smalian, log(VCC) ~  log(DAP) + log(HT), "TALHAO")

# ou
dados_smalian \%>\% 
  group_by(TALHAO) \%>\% 
  lm_table(log(VCC) ~  log(DAP) + log(HT) )
  
# Rodar regressao, e gerar tabela com coeficientes, R2 e erro,
# e anexar tabela aos dados originais:
lm_table(dados_smalian, log(VCC) ~  log(DAP) + log(HT), "TALHAO", output = "merge")

dados_smalian \%>\% 
  lm_table(log(VCC) ~  log(DAP) + log(HT),"TALHAO", output = "merge")
   
# Rodar regressao, e estimar a variavel y do modelo
dados_smalian \%>\% 
 lm_table(log(VCC) ~  log(DAP) + log(HT),"TALHAO", output = "est", est.name = "VOL_EST")
   
# Rodar regressao, e gerar dataframe com variaveis agrupadas
dados_smalian \%>\% 
 lm_table(log(VCC) ~  log(DAP) + log(HT),"TALHAO", output = "nest")
 
 
# No exemplo a seguir, estima-se a altura das arvores nao medidas
# de um inventario florestal.

# Para isso basta ajustar o modelo normalmente, e selecionar "est" como output.
# A funcao ira ajustar o modelo ignorando as arvores nao medidas
# automaticamente.
#
# Em seguida seleciona-se apenas as arvores nao medidas, e repete-se
# as arvores medidas em uma coluna separada, utilizando ifelse.

data("ex15_mfr")

dados_inv <- ex15_mfr

dados_inv <- dados_inv \%>\%  
  lm_table(log(HT) ~ inv(DAP),output = "est" ) \%>\% 
  mutate( HT_EST = if_else(is.na(HT), est, HT ) )
head(dados_inv, 20)

}
\author{
Sollano Rabelo Braga \email{sollanorb@gmail.com}
}
